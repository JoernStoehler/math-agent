# Math Agent Benchmarking System Specification

## Overview
Build a minimal web dashboard for running and monitoring math agent benchmarks on Analysis 1-3 exercise problems. Team of 3 users, ~50 total jobs expected.

## Hard Constraints
- **Minimal dependencies**: Flask only for web framework
- **Fire-and-forget jobs**: No job persistence/recovery needed
- **Single file implementation**: One Python script for the web server
- **Static file serving**: Separate simple HTTP server for file access
- **Public access**: Tunnel via cloudflared to joernstoehler.com subdomain

## Project Structure
```
math-agent/
├── server.py              # Main web server (YOUR DELIVERABLE)
├── scripts/               # Script directory
│   └── math-agent.sh      # Job runner script
├── exercises/             # Existing: ana1_s3e5.tex, etc.
├── prompts/               # Existing: v1.md, v2.md, etc. (single files)
└── jobs/                  # Auto-created job directories
    └── {job_id}/
        ├── workspace/     # Agent working directory
        │   ├── prompt.md
        │   ├── exercise.tex
        │   ├── solution.pdf      # Generated by agent
        │   └── workflow_review.md
        ├── status.json    # {"status": "scheduled|running|completed|failed"}
        └── log.jsonl      # Agent execution log
```

## Deliverable: server.py

### Core Requirements
1. **Dashboard page** (GET /): Shows all jobs with status, links to files
2. **Job submission form** (GET /submit): Create new jobs
3. **Job creation endpoint** (POST /submit): Spawn agent.sh processes
4. **Static file proxy** (GET /files/*): Serve exercises/, prompts/, jobs/ content

### Implementation Approach
- Single Python script using `http.server.BaseHTTPRequestHandler`
- Server-side HTML rendering (no JavaScript needed)
- Directory scanning for job discovery (no database)
- Process spawning for job execution

### Job Management

#### Job ID Format
```
{exercise}.{model}.{prompt_name}.{YYYYMMDD_HHMMSS}
```
Example: `ana1_s3e5.claude-sonnet-4.v1.20250628_143022`

#### Job Creation Process
1. Validate inputs (exercise exists, model valid, prompt exists, <5 running jobs)
2. Create job directory: `jobs/{job_id}/`
3. Create workspace: `jobs/{job_id}/workspace/`
4. Copy files: `exercises/{exercise} → workspace/exercise.tex`, `prompts/{prompt} → workspace/prompt.md`
5. Write initial status: `{"status": "scheduled"}`
6. Spawn process: `./scripts/math-agent.sh --job-dir jobs/{job_id} --exercise exercises/{exercise} --prompt prompts/{prompt}.md [args]`
7. Return success/error

#### Concurrent Job Limiting
- Max 5 concurrent jobs
- Check via: `ps aux | grep "agent.sh" | grep -v grep | wc -l`
- Reject submission if limit reached

### Web Interface

#### Dashboard (GET /)
**HTML Structure:**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Math Agent Benchmark Dashboard</title>
    <style>/* Inline CSS */</style>
    <meta http-equiv="refresh" content="5">
</head>
<body>
    <h1>Math Agent Benchmark Dashboard</h1>
    <p><a href="/submit">Submit New Job</a> | <a href="/files/">Browse Files</a></p>
    
    <h2>Jobs ({total_count})</h2>
    <table>
        <thead>
            <tr>
                <th>Job ID</th>
                <th>Exercise</th>
                <th>Model</th>
                <th>Prompt</th>
                <th>Status</th>
                <th>Files</th>
            </tr>
        </thead>
        <tbody>
            <!-- One row per job -->
            <tr class="status-{status}">
                <td>{job_id}</td>
                <td><a href="/files/exercises/{exercise}">{exercise}</a></td>
                <td>{model}</td>
                <td><a href="/files/prompts/{prompt}.md">{prompt}</a></td>
                <td>{status}</td>
                <td>
                    <a href="/files/jobs/{job_id}/log.jsonl">log</a>
                    {if solution.pdf exists: <a href="/files/jobs/{job_id}/workspace/solution.pdf">solution</a>}
                </td>
            </tr>
        </tbody>
    </table>
</body>
</html>
```

**CSS Requirements:**
- Clean, readable table styling
- Status-based row coloring: green=completed, yellow=running, red=failed, gray=scheduled
- Responsive layout
- Focus on quickly finding jobs and accessing key files

#### Job Submission Form (GET /submit)
```html
<form method="post" action="/submit">
    <label>Exercise:</label>
    <select name="exercise" required>
        <!-- Auto-populated from exercises/ directory -->
        <option value="ana1_s3e5">ana1_s3e5</option>
    </select>

    <label>Model:</label>
    <select name="model" required>
        <option value="claude-sonnet-4" selected>claude-sonnet-4</option>
        <option value="claude-opus-4">claude-opus-4</option>
        <!-- Add other models as needed -->
    </select>

    <label>Max Turns:</label>
    <input type="number" name="max_turns" value="100" min="1" max="200">

    <label>Prompt:</label>
    <select name="prompt_type" onchange="togglePromptInput()" required>
        <option value="existing">Use Existing Prompt</option>
        <option value="new">Create New Prompt</option>
    </select>

    <!-- Existing prompt dropdown -->
    <div id="existing_prompt">
        <select name="existing_prompt">
            <!-- Auto-populated from prompts/ directory -->
            <option value="v1">v1</option>
        </select>
        <textarea readonly id="prompt_preview"><!-- Show selected prompt content --></textarea>
    </div>

    <!-- New prompt inputs -->
    <div id="new_prompt" style="display:none">
        <input type="text" name="new_prompt_name" placeholder="Prompt name (e.g. v3)">
        <textarea name="new_prompt_content" placeholder="Prompt content..." rows="10"></textarea>
    </div>

    <button type="submit">Submit Job</button>
</form>
```

#### Static File Serving (GET /files/*)
- Proxy requests to separate file server running on port 8001
- Handle MIME types correctly (PDF, text, etc.)
- Directory listings for browsing

### Error Handling
- Job submission errors: Return form with error message
- File not found: Return 404
- Server errors: Return 500 with basic error message

### Technical Implementation Details

#### Main Server Structure (Flask)
```python
from flask import Flask, request, render_template_string, redirect, url_for
import subprocess, os, json, glob

app = Flask(__name__)

@app.route('/')
def dashboard():
    jobs = scan_jobs()
    return render_template_string(DASHBOARD_HTML, jobs=jobs)

@app.route('/submit', methods=['GET', 'POST'])
def submit_job():
    if request.method == 'POST':
        result = create_job(request.form)
        if result['success']:
            return redirect(url_for('dashboard'))
        else:
            return render_template_string(SUBMIT_HTML, error=result['error'])
    return render_template_string(SUBMIT_HTML)

@app.route('/files/<path:filename>')
def serve_files(filename):
    # Proxy to file server or serve directly

def scan_jobs():
    # Return list of job info from jobs/ directory
    
def get_running_job_count():
    # Use ps command to count agent.sh processes
    
def create_job(form_data):
    # Job creation logic, return {'success': bool, 'error': str}
```

#### File Operations
- Scan directories: `os.listdir()`, `glob.glob()`
- Read JSON status: `json.load()`
- File copying: `shutil.copy2()`
- Process spawning: `subprocess.Popen()` with detached process

### Deployment Instructions

#### Local Setup
1. Install dependencies: `pip install flask`
2. Run file server: `cd /path/to/project && python -m http.server 8001`
3. Run benchmark server: `python server.py` (Flask app on port 5000)

#### Public Access via Cloudflare Tunnel
1. Install cloudflared: 
   ```bash
   # On devcontainer/Linux:
   wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
   sudo dpkg -i cloudflared-linux-amd64.deb
   ```

2. Create tunnel (one-time setup):
   ```bash
   cloudflared tunnel login
   cloudflared tunnel create math-agent
   cloudflared tunnel route dns math-agent math-agent.joernstoehler.com
   ```

3. Run tunnel:
   ```bash
   cloudflared tunnel run --url http://localhost:5000 math-agent
   ```

#### Access URLs
- Local: http://localhost:5000/
- Public: https://math-agent.joernstoehler.com/
- File browsing: http://localhost:8001/ (local only, or add second tunnel if needed)

#### Production Deployment
```bash
# Terminal 1: File server
python -m http.server 8001

# Terminal 2: Flask app  
python server.py

# Terminal 3: Cloudflare tunnel
cloudflared tunnel run --url http://localhost:5000 math-agent
```

### Testing Checklist
- [ ] Dashboard loads and shows existing jobs
- [ ] Auto-refresh works (5 second meta refresh)
- [ ] Job submission form populates dropdowns correctly
- [ ] Job submission creates directory structure
- [ ] Job submission spawns agent.sh process
- [ ] Concurrent job limiting works
- [ ] File links work (exercises, prompts, logs, solutions)
- [ ] Error messages display for invalid submissions
- [ ] Static file serving works for all file types

### Performance Notes
- Directory scanning on each request is acceptable for <100 jobs
- No caching needed for this scale
- File server handles all static content

### Future Considerations (Out of Scope)
- Job persistence across server restarts
- Live log streaming
- Complex job scheduling
- User authentication
- Database storage

## Timeline Expectation
This should be implementable in 1-3 hours by a senior developer using Flask. The cloudflared setup adds ~15 minutes for tunnel configuration.